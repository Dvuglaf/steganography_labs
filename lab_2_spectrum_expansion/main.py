"""
–ó–∞–¥–∞–Ω–∏–µ:
1. –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é –¶–í–ó ùõ∫ –∫–∞–∫ –ø—Å–µ–≤–¥–æ—Å–ª—É—á–∞–π–Ω–æ–π –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –∑–∞–¥–∞–Ω–Ω–æ–π –¥–ª–∏–Ω—ã –∏–∑ —á–∏—Å–µ–ª,
—Ä–∞—Å–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã—Ö –ø–æ –Ω–æ—Ä–º–∞–ª—å–Ω–æ–º—É –∑–∞–∫–æ–Ω—É. –î–ª–∏–Ω–∞ 1/2 –ø–ª–æ—Å–∫–æ—Å—Ç–∏ –∏–∑ 3 –ø—É–Ω–∫—Ç–∞.

2. –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—é –∏—Å—Ö–æ–¥–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –∫ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤—É –ø—Ä–∏–∑–Ω–∞–∫–æ–≤ -
–î–í–ü (–≤–µ–π–≤–ª–µ—Ç—ã –•–∞–∞—Ä–∞), 3 —É—Ä–æ–≤–Ω—è –¥–µ–∫–æ–º–ø–æ–∑–∏—Ü–∏–∏

3. –û—Å—É—â–µ—Å—Ç–≤–∏—Ç—å –≤—Å—Ç—Ä–∞–∏–≤–∞–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –º—É–ª—å—Ç–∏–ø–ª–∏–∫–∞—Ç–∏–≤–Ω—ã–º –º–µ—Ç–æ–¥–æ–º –≤ –ø–ª–æ—Å–∫–æ—Å—Ç—å HH —Å–ø–µ–∫—Ç—Ä–∞.

4. –°—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å –Ω–æ—Å–∏—Ç–µ–ª—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –ø—Ä–∏ –ø–æ–º–æ—â–∏ –æ–±—Ä–∞—Ç–Ω–æ–≥–æ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –æ—Ç –º–∞—Ç—Ä–∏—Ü—ã –ø—Ä–∏–∑–Ω–∞–∫–æ–≤ –∫ —Ü–∏—Ñ—Ä–æ–≤–æ–º—É —Å–∏–≥–Ω–∞–ª—É.
–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –µ–≥–æ –Ω–∞ –¥–∏—Å–∫

5. –°—á–∏—Ç–∞—Ç—å –Ω–æ—Å–∏—Ç–µ–ª—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –∏–∑ —Ñ–∞–π–ª–∞ –∏ –ø–æ–≤—Ç–æ—Ä–Ω–æ –≤—ã–ø–æ–ª–Ω–∏—Ç—å –ø. 2 –¥–ª—è –Ω–æ—Å–∏—Ç–µ–ª—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏.

6. –°—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å –æ—Ü–µ–Ω–∫—É –≤—Å—Ç—Ä–æ–µ–Ω–Ω–æ–≥–æ –¶–í–ó ùõ∫ÃÉ –Ω–µ—Å–ª–µ–ø—ã–º –º–µ—Ç–æ–¥–æ–º (—Ç–æ –µ—Å—Ç—å —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –º–∞—Ç—Ä–∏—Ü—ã
–ø—Ä–∏–∑–Ω–∞–∫–æ–≤ –∏—Å—Ö–æ–¥–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞); –≤—ã–ø–æ–ª–Ω–∏—Ç—å –¥–µ—Ç–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–∏ –ø–æ–º–æ—â–∏ —Ñ—É–Ω–∫—Ü–∏–∏ –±–ª–∏–∑–æ—Å—Ç–∏ ùúå(ùõ∫, ùõ∫ÃÉ)

7. –û—Å—É—â–µ—Å—Ç–≤–∏—Ç—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–¥–±–æ—Ä –∑–Ω–∞—á–µ–Ω–∏—è –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –≤—Å—Ç—Ä–∞–∏–≤–∞–Ω–∏—è –º–µ—Ç–æ–¥–æ–º –ø–µ—Ä–µ–±–æ—Ä–∞ —Å —Ü–µ–ª—å—é –æ–±–µ—Å–ø–µ—á–µ–Ω–∏—è
ùëÉùëÜùëÅùëÖ > 30 –¥–ë (–∏–ª–∏ –ø–æ –∂–µ–ª–∞–Ω–∏—é –ª—é–±–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è, –±–æ–ª—å—à–µ–≥–æ 30 –¥–ë), –ø—Ä–∏ —ç—Ç–æ–º –≤—ã–±–∏—Ä–∞–µ—Ç—Å—è
–Ω–∞–±–æ—Ä –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π –Ω–∞–∏–±–æ–ª—å—à–µ–º—É –∑–Ω–∞—á–µ–Ω–∏—é ùúå.

8. –í—ã–ø–æ–ª–Ω–∏—Ç—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–µ –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ –ø–æ–ª—É—á–µ–Ω–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã –≤—Å—Ç—Ä–∞–∏–≤–∞–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ - ¬´Beta: Laplace¬ª
"""

import numpy as np
import pywt
import skimage.metrics
import scipy
from skimage.io import imread, imshow, show, imsave
from matplotlib import pyplot as plt


def read_image(image_path):
    return np.array(imread(image_path)).astype(np.uint8)


# –ü—Ä—è–º–æ–µ –í–µ–π–≤–ª–µ—Ç –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –•–∞–∞—Ä–∞ —Å –∑–∞–¥–∞–Ω–Ω—ã–º —É—Ä–æ–≤–Ω–µ–º –¥–µ–∫–æ–º–ø–æ–∑–∏—Ü–∏–∏
def dwt(matrix: np.array, level: int):
    return pywt.wavedec2(matrix, 'haar', level=level)


# –û–±—Ä–∞—Ç–Ω–æ–µ –í–µ–π–≤–ª–µ—Ç –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –•–∞–∞—Ä–∞
def idwt(wavelet_coeffs: np.array):
    return pywt.waverec2(wavelet_coeffs, 'haar')


# –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–æ—Ä–º–∞–ª—å–Ω–æ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞ —Å seed'–æ–º
def generate_watermark(size: int, key: int, mean=0., spread=1.):
    rng = np.random.default_rng(key)
    return rng.normal(mean, spread, size)


# –ú–µ—Ä–∞ –±–ª–∏–∑–æ—Å—Ç–∏
def get_rho(watermark: np.array, extracted_watermark: np.array):
    return np.cumsum(watermark * extracted_watermark)[-1] / \
           np.sqrt(np.cumsum(watermark ** 2)[-1] * np.cumsum(extracted_watermark ** 2)[-1])


def get_beta(matrix: np.array):
    mask = [[0, 1, 0],
            [1, -4, 1],
            [0, 1, 0]]  # –ª–∞–ø–ª–∞—Å–∏–∞–Ω
    convolved = scipy.signal.convolve2d(matrix, mask, mode='same', boundary='symm', fillvalue=0)
    convolved = np.abs(convolved)  # –∏–∑–±–∞–≤–ª–µ–Ω–∏–µ –æ—Ç –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π

    return convolved / np.max(convolved)


# –ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ—Ä–æ–≥–∞ –∫–∞–∫ –º–µ–¥–∏–∞–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ, —Å–¥–≤–∏–Ω—É—Ç–æ–µ –Ω–∞ –µ–¥–∏–Ω–∏—Ü—É –≤–ª–µ–≤–æ
def get_threshold(matrix: np.array):
    sorted_matrix = np.sort(matrix, axis=None).reshape((matrix.shape[0], matrix.shape[1]))
    return sorted_matrix[(matrix.shape[0] - 1) // 2, (matrix.shape[1] - 1) - 1]


# –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –º–∞—Ç—Ä–∏—Ü—ã –≤ –º–∞—Å—Å–∏–≤ –¥–∏–∞–≥–æ–Ω–∞–ª–µ–π, –ø–æ–ª—É—á–µ–Ω–Ω—ã—Ö –ø—Ä–∏ –∑–∏–≥–∑–∞–≥–æ–æ–±—Ä–∞–∑–Ω–æ–º –ø—Ä–æ—Ö–æ–¥–µ –º–∞—Ç—Ä–∏—Ü—ã
def get_matrix_diagonals(matrix: np.array):
    diagonals_count = matrix.shape[0] + matrix.shape[1] - 1

    horizontal_flip = np.fliplr(matrix)  # –æ—Ç—Ä–∞–∂–µ–Ω–∏–µ –≤–¥–æ–ª—å –û–£, –ø–æ—Ä—è–¥–æ–∫ —Å–≤–µ—Ä—Ö—É-–≤–Ω–∏–∑ –≤ –∏—Å—Ö–æ–¥–Ω–æ–π
    vertical_flip = np.flipud(matrix)  # –æ—Ç—Ä–∞–∂–µ–Ω–∏–µ –≤–¥–æ–ª—å –û–•, –ø–æ—Ä—è–¥–æ–∫ —Å–Ω–∏–∑—É-–≤–≤–µ—Ä—Ö –≤ –∏—Å—Ö–æ–¥–Ω–æ–π

    diagonals = []

    # –í –∫–∞–∂–¥–æ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ –ø–æ diagonals_count//2 –¥–∏–∞–≥–æ–Ω–∞–ª–µ–π, –æ–±—Ö–æ–¥–∏–º –∏—Ö –≤—Å–µ
    for i in range(-(diagonals_count // 2), diagonals_count // 2 + 1):
        if i % 2 == 0:  # –Ω–µ—á–µ—Ç–Ω–∞—è –¥–∏–∞–≥–æ–Ω–∞–ª—å (–ø–æ –Ω–æ–º–µ—Ä—É)
            diagonals.append(list(horizontal_flip.diagonal(-i)))
        else:  # —á–µ—Ç–Ω–∞—è –¥–∏–∞–≥–æ–Ω–∞–ª—å (–ø–æ –Ω–æ–º–µ—Ä—É)
            diagonals.append(list(vertical_flip.diagonal(i)))

    return diagonals


# –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –º–∞—Å—Å–∏–≤–∞ –¥–∏–∞–≥–æ–Ω–∞–ª–µ–π –≤ –º–∞—Ç—Ä–∏—Ü—É
def diagonals_to_matrix(diagonals: np.array):
    diagonals_count = len(diagonals)

    matrix = np.zeros((diagonals_count // 2 + 1, diagonals_count // 2 + 1))

    horizontal_flip = np.fliplr(matrix)  # –æ—Ç—Ä–∞–∂–µ–Ω–∏–µ –≤–¥–æ–ª—å –û–£, –ø–æ—Ä—è–¥–æ–∫ —Å–≤–µ—Ä—Ö—É-–≤–Ω–∏–∑ –∏ —Å–ø—Ä–∞–≤–∞-–Ω–∞–ª–µ–≤–æ –≤ –∏—Å—Ö–æ–¥–Ω–æ–π
    vertical_flip = np.flipud(matrix)  # –æ—Ç—Ä–∞–∂–µ–Ω–∏–µ –≤–¥–æ–ª—å –û–•, –ø–æ—Ä—è–¥–æ–∫ —Å–Ω–∏–∑—É-–≤–≤–µ—Ä—Ö –∏ —Å–ª–µ–≤–∞-–Ω–∞–ø—Ä–∞–≤–æ –≤ –∏—Å—Ö–æ–¥–Ω–æ–π

    # –í –∫–∞–∂–¥–æ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ –ø–æ diagonals_count//2 –¥–∏–∞–≥–æ–Ω–∞–ª–µ–π, –æ–±—Ö–æ–¥–∏–º –∏—Ö –≤—Å–µ
    for i in range(-(diagonals_count // 2), diagonals_count // 2 + 1):
        if i % 2 == 0:  # –Ω–µ—á–µ—Ç–Ω–∞—è –¥–∏–∞–≥–æ–Ω–∞–ª—å (–ø–æ –Ω–æ–º–µ—Ä—É)
            if i > 0:
                np.fill_diagonal(horizontal_flip[i:, :],
                                 diagonals[i + diagonals_count // 2])  # –∫–æ–º–ø–µ–Ω—Å–∞—Ü–∏—è –¥–ª—è –≤—Å—Ç–∞–≤–∫–∏ (–Ω–∞—á–∏–Ω–∞—è —Å i = 1)
            else:  # –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–µ —Å–º–µ—â–µ–Ω–∏–µ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –ø–æ–±–æ—á–Ω–æ–π –¥–∏–∞–≥–æ–Ω–∞–ª–∏ (–≤—Å—Ç–∞–≤–∫–∞ –≤ –ª–µ–≤—É—é —á–∞—Å—Ç—å –º–∞—Ç—Ä–∏—Ü—ã)
                np.fill_diagonal(horizontal_flip[:, -i:],
                                 diagonals[i + diagonals_count // 2])  # –∫–æ–º–ø–µ–Ω—Å–∞—Ü–∏—è —Å–º–µ—â–µ–Ω–∏—è
        else:  # —á–µ—Ç–Ω–∞—è –¥–∏–∞–≥–æ–Ω–∞–ª—å (–ø–æ –Ω–æ–º–µ—Ä—É)
            if i > 0:
                np.fill_diagonal(vertical_flip[:, i:],
                                 diagonals[i + diagonals_count // 2])  # –∫–æ–º–ø–µ–Ω—Å–∞—Ü–∏—è —Å–º–µ—â–µ–Ω–∏—è
            else:  # –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–µ —Å–º–µ—â–µ–Ω–∏–µ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –ø–æ–±–æ—á–Ω–æ–π –¥–∏–∞–≥–æ–Ω–∞–ª–∏ (–≤—Å—Ç–∞–≤–∫–∞ –≤ –ª–µ–≤—É—é —á–∞—Å—Ç—å –º–∞—Ç—Ä–∏—Ü—ã)
                np.fill_diagonal(vertical_flip[-i:, ],
                                 diagonals[i + diagonals_count // 2])  # –∫–æ–º–ø–µ–Ω—Å–∞—Ü–∏—è —Å–º–µ—â–µ–Ω–∏—è

    return matrix


def embedding(image: np.array, key: int, alpha: float, level: int, modified: bool):
    wavelet_coeffs = dwt(image, level)
    hh_zone = wavelet_coeffs[1][2]

    watermark_size = hh_zone.shape[0] * hh_zone.shape[1] // 2
    watermark = generate_watermark(watermark_size, key)

    diagonals = get_matrix_diagonals(hh_zone)

    threshold = get_threshold(hh_zone)
    w_i = 0  # –¥–ª—è –ø—Ä–æ—Ö–æ–¥–∞ –ø–æ –º–∞—Å—Å–∏–≤—É watermark

    # –ü—Ä–æ—Ö–æ–¥ –ø–æ —ç–ª–µ–º–µ–Ω—Ç–∞–º –ø–æ–ª—É—á–µ–Ω–Ω—ã—Ö –¥–∏–∞–≥–æ–Ω–∞–ª–µ–π, –Ω–∞—á–∏–Ω–∞—è —Å–æ 2-–æ–π –ø–æ –Ω–æ–º–µ—Ä—É –¥–∏–∞–≥–æ–Ω–∞–ª–∏
    for i in range(1, len(diagonals)):  # –æ–±—Ö–æ–¥ –≤—Å–µ—Ö –¥–∏–∞–≥–æ–Ω–∞–ª–µ–π
        for j in range(len(diagonals[i])):  # –æ–±—Ö–æ–¥ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤ –¥–∏–∞–≥–æ–Ω–∞–ª–∏
            if np.absolute(diagonals[i][j]) > np.absolute(threshold):
                diagonals[i][j] *= (1 + alpha * watermark[w_i])
                w_i += 1
                if w_i == watermark_size:
                    break
        else:
            continue  # –≤—ã–ø–æ–ª–Ω–∏—Ç—Å—è –≤ –∫–æ–Ω—Ü–µ –∫–∞–∂–¥–æ–π –∏—Ç–µ—Ä–∞—Ü–∏–∏, –µ—Å–ª–∏ –Ω–µ –±—ã–ª–æ break –∏–∑ –≤–ª–æ–∂–µ–Ω–Ω–æ–≥–æ —Ü–∏–∫–ª–∞
        break  # –≤—ã–ø–æ–ª–Ω–∏—Ç—Å—è —Ç–æ–ª—å–∫–æ –≤ —Å–ª—É—á–∞–µ break –≤–ª–æ–∂–µ–Ω–Ω–æ–≥–æ —Ü–∏–∫–ª–∞

    marked_hh_zone = diagonals_to_matrix(diagonals)

    # –ò–∑-–∑–∞ –Ω–µ–∏–∑–º–µ–Ω—è–µ–º–æ—Å—Ç–∏ tuple –ø—Ä–∏—Ö–æ–¥–∏—Ç—Å—è –¥–µ–ª–∞—Ç—å –∫–∞—Å—Ç –∫ list, –º–µ–Ω—è—Ç—å –≤ –Ω–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –∏ –∑–∞—Ç–µ–º –≤—Å—Ç–∞–≤–ª—è—Ç—å –æ–±—Ä–∞—Ç–Ω–æ
    wavelet_coeffs_list = list(wavelet_coeffs[1])
    wavelet_coeffs_list[2] = marked_hh_zone
    wavelet_coeffs.pop(1)  # —É–¥–∞–ª–µ–Ω–∏–µ –∏—Å—Ö–æ–¥–Ω–æ–≥–æ tuple
    wavelet_coeffs_tuple = tuple(wavelet_coeffs_list)
    wavelet_coeffs.insert(1, wavelet_coeffs_tuple)  # –≤—Å—Ç–∞–≤–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–Ω–æ–≥–æ tuple

    if not modified:  # –æ–±—ã—á–Ω–æ–µ –≤—Å—Ç—Ä–∞–∏–≤–∞–Ω–∏–µ
        return idwt(wavelet_coeffs), watermark
    else:  # –º–æ–¥–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –≤—Å—Ç—Ä–∞–∏–≤–∞–Ω–∏–µ —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–º beta
        beta = get_beta(image)
        return idwt(wavelet_coeffs) * beta + image * (1 - beta), watermark


def extracting(marked_image: np.array, image: np.array, alpha: float, level: int):
    wavelet_coeffs = dwt(marked_image, level)
    marked_hh_zone = wavelet_coeffs[1][2]

    wavelet_coeffs = dwt(image, level)
    hh_zone = wavelet_coeffs[1][2]

    watermark_size = hh_zone.shape[0] * hh_zone.shape[1] // 2
    watermark = np.zeros(watermark_size)

    diagonals_original = get_matrix_diagonals(hh_zone)
    diagonals_marked = get_matrix_diagonals(marked_hh_zone)

    threshold = get_threshold(hh_zone)
    w_i = 0

    # –ü—Ä–æ—Ö–æ–¥ –ø–æ —ç–ª–µ–º–µ–Ω—Ç–∞–º –ø–æ–ª—É—á–µ–Ω–Ω—ã—Ö –¥–∏–∞–≥–æ–Ω–∞–ª–µ–π, –Ω–∞—á–∏–Ω–∞—è —Å–æ 2-–æ–π (–ø–æ –Ω–æ–º–µ—Ä—É) –¥–∏–∞–≥–æ–Ω–∞–ª–∏
    for i in range(1, len(diagonals_original)):  # –æ–±—Ö–æ–¥ –≤—Å–µ—Ö –¥–∏–∞–≥–æ–Ω–∞–ª–µ–π
        for j in range(len(diagonals_original[i])):  # –æ–±—Ö–æ–¥ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –¥–∏–∞–≥–æ–Ω–∞–ª–∏
            if np.absolute(diagonals_original[i][j]) > np.absolute(threshold):
                watermark[w_i] = (diagonals_marked[i][j] - diagonals_original[i][j]) / \
                                 (alpha * diagonals_original[i][j])
                w_i += 1
                if w_i == watermark_size:
                    return watermark

    return watermark


# –ü–æ–ª—É—á–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è alpha, –ø—Ä–∏ –∫–æ—Ç–æ—Ä–æ–º rho –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ
def get_best_alpha(image: np.array, key: int, level: int, modified: bool):
    current_alpha = 0.1
    best_alpha = 0.
    max_rho = 0.

    for i in range(10):
        marked_image, watermark = embedding(image, key, current_alpha, level, modified=modified)
        extracted_watermark = extracting(marked_image, image, current_alpha, level)

        rho = get_rho(watermark, extracted_watermark)
        psnr = skimage.metrics.peak_signal_noise_ratio(image, marked_image)

        if rho > max_rho and psnr > 30:
            max_rho = rho
            best_alpha = current_alpha

        current_alpha += 0.1

    return best_alpha, max_rho


def watermark_detection(extracted_watermark, threshold, key):
    size = len(extracted_watermark)
    watermark = generate_watermark(size, key)
    rho = get_rho(watermark, extracted_watermark)
    if rho > threshold:
        return True
    else:
        return False


def plot(image, marked_image, watermark, extracted_watermark, alpha, rho, psnr, modified):
    print(f"Best alpha = {alpha}")
    print(f"Rho = {rho}")
    print(f"PSNR = {psnr}")
    print(f"MAE between watermarks = {np.average(np.abs(watermark - extracted_watermark))}")
    print(f"MAE between images = {np.average(np.abs(marked_image.astype(int) - image.astype(int)))}")

    fig = plt.figure()
    sp = fig.add_subplot(1, 2, 1)
    sp.set_title("–ò—Å—Ö–æ–¥–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ")
    imshow(image, cmap='gray')

    sp = fig.add_subplot(1, 2, 2)
    sp.set_title("–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å –¶–í–ó")
    imshow(marked_image, cmap='gray', vmin=0, vmax=255)

    fig = plt.figure()
    sp = fig.add_subplot(1, 1, 1)
    sp.set_title("Difference between image and marked image")
    imshow(np.absolute(marked_image.astype(int) - image.astype(int)), cmap='gray')

    if modified:
        beta = get_beta(image)
        fig = plt.figure()
        sp = fig.add_subplot(1, 1, 1)
        sp.set_title("Beta")
        imshow(beta, cmap='gray')

    show()


def main():
    level = 3  # —É—Ä–æ–≤–µ–Ω—å –¥–µ–∫–æ–º–ø–æ–∑–∏—Ü–∏–∏
    image = read_image("./images/bridge.tif")
    key = 321
    modified = False
    detection_threshold = 0.2

    best_alpha, _ = get_best_alpha(image, key, level, modified)

    marked_image, watermark = embedding(image, key, best_alpha, level, modified)
    imsave("./images/marked_image.png", marked_image)

    marked_image = read_image("./images/marked_image.png")
    extracted_watermark = extracting(marked_image, image, best_alpha, level)

    rho = get_rho(watermark, extracted_watermark)
    psnr = skimage.metrics.peak_signal_noise_ratio(image, marked_image)

    print(f"Watermark with key {key} detected: {watermark_detection(extracted_watermark, detection_threshold, key)}")

    plot(image, marked_image, watermark, extracted_watermark, best_alpha, rho, psnr, modified)


main()
